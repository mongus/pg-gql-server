#!/bin/bash
set -e

case "${USER_ID_TYPE^^}" in
  'UUID')
    USER_ID_GENERATOR=' DEFAULT GEN_RANDOM_UUID()'
    ;;
  'INTEGER')
    USER_ID_GENERATOR=' GENERATED BY DEFAULT AS IDENTITY'
    ;;
  'BIGINT')
    USER_ID_GENERATOR='GENERATED BY DEFAULT AS IDENTITY'
    ;;
  *)
    echo "Invalid USER_ID_TYPE: ${USER_ID_TYPE}"
    exit 1
    ;;
esac

# Use the environment variable EXTRA_USER_PASSWORD to create a new user
psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" "${POSTGRES_DB}" <<-EOSQL
    CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
    CREATE EXTENSION IF NOT EXISTS "pgcrypto";
    CREATE EXTENSION IF NOT EXISTS "citext";

    -- Create PostGraphile user
    CREATE ROLE ${POSTGRAPHILE_USER} WITH LOGIN PASSWORD '${POSTGRAPHILE_PASSWORD}';
    -- Grant all privileges on the database to the PostGraphile user
    GRANT ALL PRIVILEGES ON DATABASE ${POSTGRES_DB} TO ${POSTGRAPHILE_USER};

    CREATE ROLE superadmin WITH SUPERUSER;
    GRANT superadmin TO ${POSTGRAPHILE_USER};

    CREATE ROLE anonymous;
    GRANT anonymous TO ${POSTGRAPHILE_USER};

    CREATE ROLE ${POSTGRAPHILE_USER}_user;
    GRANT ${POSTGRAPHILE_USER}_user TO ${POSTGRAPHILE_USER};

    -- Create the exposed schema if necessary
    CREATE SCHEMA IF NOT EXISTS ${EXPOSED_SCHEMA};
    -- Grant all privileges on the exposed schema to the PostGraphile user
    ALTER SCHEMA ${EXPOSED_SCHEMA} OWNER TO ${POSTGRAPHILE_USER};

    \\c ${POSTGRES_DB} ${POSTGRAPHILE_USER}

    -- Create the auth schema that will manage user authentication
    CREATE SCHEMA IF NOT EXISTS ${AUTH_SCHEMA};

    -- Create the ${AUTH_SCHEMA}.jwt_token type that is used by PostGraphile
    CREATE TYPE ${AUTH_SCHEMA}.jwt_token AS (role TEXT, exp INTEGER, uid ${USER_ID_TYPE});
    COMMENT ON TYPE ${AUTH_SCHEMA}.jwt_token IS 'JWT token injected by PostGraphile.';

    CREATE OR REPLACE FUNCTION ${AUTH_SCHEMA}.uid() RETURNS ${USER_ID_TYPE} AS \$\$
      SELECT NULLIF(CURRENT_SETTING('jwt.claims.uid', TRUE), '')::${USER_ID_TYPE};
    \$\$ LANGUAGE SQL;
    GRANT EXECUTE ON FUNCTION ${AUTH_SCHEMA}.uid() TO PUBLIC;

    -- Create basic user table
    CREATE TABLE IF NOT EXISTS ${EXPOSED_SCHEMA}.users (
      id ${USER_ID_TYPE} PRIMARY KEY ${USER_ID_GENERATOR},
      first_name TEXT,
      last_name TEXT,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      archived_at TIMESTAMPTZ
    );
    COMMENT ON TABLE ${EXPOSED_SCHEMA}.users IS
      E'@behavior -insert -delete';
    GRANT SELECT ON ${EXPOSED_SCHEMA}.users TO ${POSTGRAPHILE_USER}_user;
    ALTER TABLE ${EXPOSED_SCHEMA}.users ENABLE ROW LEVEL SECURITY;
    CREATE POLICY owner_policy ON ${EXPOSED_SCHEMA}.users
      TO ${POSTGRAPHILE_USER}_user
      USING (id = ${AUTH_SCHEMA}.uid());

    -- Create the local login table
    CREATE TABLE IF NOT EXISTS ${AUTH_SCHEMA}.local_logins (
      user_id ${USER_ID_TYPE} PRIMARY KEY REFERENCES ${EXPOSED_SCHEMA}.users(id),
      username CITEXT UNIQUE,
      email CITEXT UNIQUE,
      password TEXT NOT NULL DEFAULT 'EMPTY',
      role TEXT NOT NULL DEFAULT '${POSTGRAPHILE_USER}_user',
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      archived_at TIMESTAMPTZ
    );
    COMMENT ON TABLE ${AUTH_SCHEMA}.local_logins IS
      'Local (non-federated) login using email and password.';
    ALTER TABLE ${AUTH_SCHEMA}.local_logins ENABLE ROW LEVEL SECURITY;

    CREATE FUNCTION ${AUTH_SCHEMA}.hash_password(password TEXT) RETURNS TEXT AS \$\$
      SELECT crypt(password, gen_salt('bf'));
    \$\$ LANGUAGE SQL;
    GRANT EXECUTE ON FUNCTION ${AUTH_SCHEMA}.hash_password(TEXT) TO PUBLIC;

    -- Create the super admin user
    WITH new_user AS (
      INSERT INTO users (first_name, last_name)
      VALUES ('Super', 'Admin')
      RETURNING id
    )
    INSERT INTO ${AUTH_SCHEMA}.local_logins (user_id, username, role, password)
    SELECT id, '${ADMIN_USER}', 'superadmin', ${AUTH_SCHEMA}.hash_password('${ADMIN_PASSWORD}')
    FROM new_user;

    -- Create authenticate function
    CREATE OR REPLACE FUNCTION ${EXPOSED_SCHEMA}.authenticate(
      username TEXT,
      password TEXT
    ) RETURNS ${AUTH_SCHEMA}.jwt_token as \$\$
    DECLARE
      local_login ${AUTH_SCHEMA}.local_logins;
      user_id ${USER_ID_TYPE};
    BEGIN
      IF \$1 LIKE '%@%' THEN
        SELECT
         * INTO local_login
        FROM ${AUTH_SCHEMA}.local_logins l
        WHERE
         email = \$1
         AND archived_at IS NULL
         AND CRYPT(\$2, l.password) = l.password;
      END IF;

      IF local_login IS NULL THEN
        SELECT
         * INTO local_login
        FROM ${AUTH_SCHEMA}.local_logins l
        WHERE
         l.username = \$1
         AND archived_at IS NULL
         AND CRYPT(\$2, l.password) = l.password;
      END IF;

      IF local_login IS NULL THEN
        RETURN NULL;
      END IF;

      SELECT
       id INTO user_id
      FROM ${EXPOSED_SCHEMA}.users
      WHERE
       id = local_login.user_id
       AND archived_at IS NULL;

      IF user_id IS NULL THEN
        RETURN NULL;
      END IF;

      RETURN (local_login.role, EXTRACT(EPOCH FROM NOW()) + (${JWT_TTL}), user_id)::${AUTH_SCHEMA}.jwt_token;
    END;
    \$\$ LANGUAGE PLPGSQL STRICT SECURITY DEFINER;
    GRANT EXECUTE ON FUNCTION ${EXPOSED_SCHEMA}.authenticate(TEXT, TEXT) TO PUBLIC;
EOSQL
